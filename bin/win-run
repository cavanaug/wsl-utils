#!/bin/bash
#  ┌────────────────────────────────────────────────────────────────┐
#  │                                                                │
#  │    ██╗    ██╗██╗███╗   ██╗      ██████╗ ██╗   ██╗███╗   ██╗    │
#  │    ██║    ██║██║████╗  ██║      ██╔══██╗██║   ██║████╗  ██║    │
#  │    ██║ █╗ ██║██║██╔██╗ ██║█████╗██████╔╝██║   ██║██╔██╗ ██║    │
#  │    ██║███╗██║██║██║╚██╗██║╚════╝██╔══██╗██║   ██║██║╚██╗██║    │
#  │    ╚███╔███╔╝██║██║ ╚████║      ██║  ██║╚██████╔╝██║ ╚████║    │
#  │     ╚══╝╚══╝ ╚═╝╚═╝  ╚═══╝      ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝    │
#  │                                                                │
#  └────────────────────────────────────────────────────────────────┘
#  - This script is used to run windows programs via Windows PowerShell from WSL.
#  - It takes an executable name and arguments as input.
#    - Any argument that is a file or directory will be converted to a windows path
#  - If the command is part of a pipe (!isatty) it will attempt to coerce output to utf-8 with unix line endings
#  - It will run the command in powershell attempting to find it using the windows PATH
#    - Utilize winutil alias to create alias mappings that have a full path for items not in PATH
#
WIN_WINDIR=${WIN_WINDIR:-/mnt/c/Windows}
POWERSHELL_EXE="${WIN_WINDIR}/System32/WindowsPowerShell/v1.0/powershell.exe"

#
# Forcibly ensure that output is UTF-8 encoded, need to peek at input to detect if its
# utf-16le (aka unicode) or if its already utf-8.   This is essential for processing output
# from windows called via powershell.   I have found  no mechanism to do this reliably
# in bash directly.   This is performed as an embedded python3 script so as not to add yet
# another script to the system.
#
function ensure_utf8 {
    # Pipe stdin directly to the python3 interpreter.
    # The 'EOF' is quoted to prevent shell expansion within the Python code,
    # ensuring the code is passed literally.
    python3 -c '
import sys

def main():
    # Read the ENTIRE raw byte stream from stdin.
    # .buffer is the crucial part that provides binary-safe I/O.
    try:
        input_bytes = sys.stdin.buffer.read()
    except (IOError, KeyboardInterrupt):
        # Handle cases where the pipe might be broken or user interrupts.
        return

    # If there is no input, there is nothing to do.
    if not input_bytes:
        return

    # Default to assuming the input is already valid.
    output_bytes = input_bytes

    # Heuristic check for UTF-16LE (with or without BOM).
    if len(input_bytes) >= 2:
        # Case 1: Check for the standard UTF-16LE BOM (FF FE).
        is_bom_utf16le = input_bytes.startswith(b"\xff\xfe")

        # Case 2: Check for BOM-less UTF-16LE (ASCII char followed by null).
        is_bomless_utf16le = (input_bytes[1] == 0 and input_bytes[0] != 0)

        if is_bom_utf16le or is_bomless_utf16le:
            try:
                # Decode the bytes from UTF-16LE into a standard Python string.
                decoded_string = input_bytes.decode("utf-16-le")
                # Re-encode the string into our target format: UTF-8.
                output_bytes = decoded_string.encode("utf-8")
            except UnicodeDecodeError:
                # If decoding fails for some reason (e.g., malformed stream),
                # fall back to printing the original bytes to avoid data loss.
                pass

    # Write the resulting bytes to stdout, again using the binary buffer.
    try:
        sys.stdout.buffer.write(output_bytes)
        sys.stdout.buffer.flush()
    except (IOError, KeyboardInterrupt):
        # Handle broken pipe on output.
        pass

if __name__ == "__main__":
    main()
'
}

CMDARGS=()
RAW_OUTPUT=false

if [[ -L "$0" ]]; then
    # Invoked via symlink
    SYM="SYM-"
    CMD=$(basename "$0")
    ARGS_TO_PROCESS=("$@")
else
    # Invoked directly
    SYM=""
    if [[ "$1" == "--raw" ]]; then
        RAW_OUTPUT=true
        shift # Remove --raw, $1 is now the command
    fi
    CMD="$(wslpath -w "$1")" # $1 is the command
    shift                    # Remove the command itself
    ARGS_TO_PROCESS=("$@")   # Remaining are arguments to the command
fi

# Process arguments for path conversion
for i in "${ARGS_TO_PROCESS[@]}"; do
    if [[ -f $i || -d $i ]]; then
        # Anything that is a file or directory will be converted to a windows path, potentially with a substituted drive letter
        # Use the -W flag to invoke the substitution logic in our wrapper
        CMDARGS+=("$(wslpath -w "${i}")")
    else
        CMDARGS+=("${i}")
    fi
done

# Debug/Logging
mkdir -p ${HOME}/.local/state/wslutil
echo "win-run ${RAW_FLAG_LOG}${SYM}${CMD} ${CMDARGS[@]}" >>${HOME}/.local/state/wslutil/win-run.log

set -euo pipefail
if [ "$RAW_OUTPUT" = true ]; then
    "$POWERSHELL_EXE" -Command "& \"${CMD}\" ${CMDARGS[@]}"
else
    "$POWERSHELL_EXE" -Command "[Console]::OutputEncoding = [System.Text.Encoding]::UTF8; \$OutputEncoding = [System.Text.Encoding]::UTF8; & \"${CMD}\" ${CMDARGS[@]}" | ensure_utf8
fi
