#!/bin/bash
#  ┌────────────────────────────────────────────────────────────────┐
#  │                                                                │
#  │    ██╗    ██╗██╗███╗   ██╗      ██████╗ ██╗   ██╗███╗   ██╗    │
#  │    ██║    ██║██║████╗  ██║      ██╔══██╗██║   ██║████╗  ██║    │
#  │    ██║ █╗ ██║██║██╔██╗ ██║█████╗██████╔╝██║   ██║██╔██╗ ██║    │
#  │    ██║███╗██║██║██║╚██╗██║╚════╝██╔══██╗██║   ██║██║╚██╗██║    │
#  │    ╚███╔███╔╝██║██║ ╚████║      ██║  ██║╚██████╔╝██║ ╚████║    │
#  │     ╚══╝╚══╝ ╚═╝╚═╝  ╚═══╝      ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝    │
#  │                                                                │
#  └────────────────────────────────────────────────────────────────┘
#  - This script is used to run windows programs via Windows PowerShell from WSL.
#  - It takes an executable name and arguments as input.
#    - Any argument that is a file or directory will be converted to a windows path
#  - If the command is part of a pipe (!isatty) it will attempt to coerce output to utf-8 with unix line endings
#  - It will run the command in powershell attempting to find it using the windows PATH
#    - Utilize winutil alias to create alias mappings that have a full path for items not in PATH
#
WIN_WINDIR=${WIN_WINDIR:-/mnt/c/Windows}
POWERSHELL_EXE="${WIN_WINDIR}/System32/WindowsPowerShell/v1.0/powershell.exe"

# Define path to the custom wslpath wrapper

CMDARGS=()

RAW_OUTPUT=false

if [[ -L "$0" ]]; then
    # Invoked via symlink
    SYM="SYM-"
    CMD=$(basename "$0")
    ARGS_TO_PROCESS_TEMP=("$@")
    if [[ "${ARGS_TO_PROCESS_TEMP[0]}" == "--raw" ]]; then
        RAW_OUTPUT=true
        # Slice the array from the second element if --raw is present
        ARGS_TO_PROCESS=("${ARGS_TO_PROCESS_TEMP[@]:1}")
    else
        ARGS_TO_PROCESS=("${ARGS_TO_PROCESS_TEMP[@]}")
    fi
else
    # Invoked directly
    SYM=""
    if [[ "$1" == "--raw" ]]; then
        RAW_OUTPUT=true
        shift # Remove --raw, $1 is now the command
    fi
    CMD="$(wslpath -w "$1")" # $1 is the command
    shift # Remove the command itself
    ARGS_TO_PROCESS=("$@") # Remaining are arguments to the command
fi

# Process arguments for path conversion
for i in "${ARGS_TO_PROCESS[@]}"; do
    if [[ -f $i || -d $i ]]; then
        # Anything that is a file or directory will be converted to a windows path, potentially with a substituted drive letter
        # Use the -W flag to invoke the substitution logic in our wrapper
        CMDARGS+=("$(wslpath -w "${i}")")
    else
        CMDARGS+=("${i}")
    fi
done
if [ "$RAW_OUTPUT" = true ]; then
    "$POWERSHELL_EXE" -Command "& \"${CMD}\" ${CMDARGS[@]}"
else
    "$POWERSHELL_EXE" -Command "& \"${CMD}\" ${CMDARGS[@]}" | iconv -f UTF-16LE -t UTF-8 | dos2unix
fi
# $POWERSHELL_EXE -Command '[Console]::OutputEncoding = [System.Text.Encoding]::UTF8; $OutputEncoding = [System.Text.Encoding]::UTF8; '"${CMD} ${CMDARGS[@]}"
#$POWERSHELL_EXE -Command '[Console]::OutputEncoding = [System.Text.Encoding]::UTF8; $OutputEncoding = [System.Text.Encoding]::UTF8; '"${CMD} ${CMDARGS[@]}"

mkdir -p ${HOME}/.local/state/wslutil
RAW_FLAG_LOG=""
if [ "$RAW_OUTPUT" = true ]; then
    RAW_FLAG_LOG="--raw "
fi
echo "win-run ${RAW_FLAG_LOG}${SYM}${CMD} ${CMDARGS[@]}" >>${HOME}/.local/state/wslutil/win-run.log
exit 0
